module segmentDisplay(
	input csi_clk,
	input rsi_reset_n,
	
	// Avalon MM
	
	input avs_s0_write,
	input avs_s0_read,
	input[4:0] avs_s0_address,
	input[31:0] avs_s0_writedata,
	
	output reg[31:0] avs_s0_readdata,
	
	// Output 
	output reg[3:0] out_dig,
	output reg[7:0] out_segment
);

localparam CHAR_LEN = 5;
localparam LEN = 4;

wire[CHAR_LEN - 1:0] number[LEN - 1:0];

wire dot[LEN - 1 : 0];

wire ena;

wire[7:0] segment[LEN - 1:0];

wire freq;

wire[LEN - 1:0] inSelect;
wire[7:0] inSegment;

sD_avalon_interface sdc(.csi_clk(csi_clk),
								.rsi_reset_n(rsi_reset_n),
	
								.avs_s0_write(avs_s0_write),
								.avs_s0_read(avs_s0_read),
								.avs_s0_address(avs_s0_address),
								.avs_s0_writedata(avs_s0_writedata),
	
								.avs_s0_readdata(avs_s0_readdata),
									
								.number1(number[0]),
								.number2(number[1]),
								.number3(number[2]),
								.number4(number[3]),
								
								.dot1(dot0),
								.dot2(dot1),
								.dot3(dot2),
								.dot4(dot3),
								
								.ena(ena)
);

fromDecToSegment dis1(.clk(csi_clk),
							 .rst(rsi_reset_n),
							 
							 .ena(ena),
							 .number(number[0]),
							 .dot(dot[0]),
	
							 .segments(segment[0])
);

fromDecToSegment dis2(.clk(csi_clk),
							 .rst(rsi_reset_n),
							 
							 .ena(ena),
							 .number(number[1]),
							 .dot(dot[1]),
	
							 .segments(segment[1])
);

fromDecToSegment dis3(.clk(csi_clk),
							 .rst(rsi_reset_n),
							 
							 .ena(ena),
							 .number(number[2]),
							 .dot(dot[2]),
	
							 .segments(segment[2])
);

fromDecToSegment dis4(.clk(csi_clk),
							 .rst(rsi_reset_n),
							 
							 .ena(ena),
							 .number(number[3]),
							 .dot(dot[3]),
	
							 .segments(segment[3])
);


frequencyGen fG(.clk(csi_clk),
				    .rst(rsi_reset_n),
	
					 .freq(freq)
);

displayMultiplex dM(.clk(csi_clk),
						  .rst(rsi_reset_n),
						 
						  .freq(freq),
	
					   	.segment1(segment[0]),
						   .segment2(segment[1]),
					   	.segment3(segment[2]),
					   	.segment4(segment[3]),
	
							.select(inSelect),
							.seg(inSegment)
);


outBuffer oB(.clk(csi_clk),
				 .rst(rsi_reset_n),
	
				.inSegment(inSegment),
				.inSelect(inSelect),
				
				.segment(out_segment),
				.select(out_dig)
);
endmodule

module outBuffer(
	input clk,
	input rst,
	
	input[7:0] inSegment,
	input[3:0] inSelect,
	
	output reg[7:0] segment,
	output reg[3:0] select
);

always@(posedge clk or posedge rst)
	if(rst) begin
		segment <= 0;
		select <= 0;	
	end
	else begin
		segment <= ~inSegment;
		select <= ~inSelect;
	end
	
endmodule


module displayMultiplex(
	input clk,
	input rst,
	
	input freq,
	
	input[7:0] segment1,
	input[7:0] segment2,
	input[7:0] segment3,
	input[7:0] segment4,
	
	output reg[3:0] select,
	output reg[7:0] seg
);

localparam LEN = 2;

reg[3:0] f_select;
reg[7:0] f_segment;

reg[LEN - 1:0] f_tim;
reg[LEN - 1:0] n_tim;

always@(posedge clk or posedge rst)begin
	if(rst) begin
		f_tim <= 0;
		f_segment <= 0;
		f_select <= 0;
		end
	else begin
		f_tim <= n_tim;
		f_segment <= seg;
		f_select <= select;
		end
end

always@(*)begin
	n_tim = f_tim;

	if(freq) n_tim = f_tim + 1;

end

always@(*)begin
	seg = f_segment;
	
	case(f_tim)
		0: seg = segment1;
		1: seg = segment2;
		2: seg = segment3;
		3: seg = segment4;
	endcase
	
end

always@(*)begin

	select = f_select;
	
	case(f_tim)
		0: select = 4'b1000;
		1: select = 4'b0100;
		2: select = 4'b0010;
		3: select = 4'b0001;
		default:;
	endcase
end

endmodule

module frequencyGen #(
	parameter SPEED = 23
)(
	input clk,
	input rst,
	
	output reg freq
);

reg[SPEED - 1: 0] f_tim;
reg[SPEED - 1: 0] n_tim;

always@(posedge clk or posedge rst)
	if(rst) f_tim <= 0;
	else f_tim <= n_tim;

always@(*)begin
	n_tim = f_tim + 1;
	freq = 0;
	
	if(f_tim == 0) freq = 1;
	
end
endmodule

module fromDecToSegment(
	input clk,
	input rst,
	input ena,
	input[4:0] number,
	input dot,
	
	output reg[7:0] segments
);

reg[7:0] n_segments;

reg A = 0;
reg B = 0;
reg C = 0;
reg D = 0;
reg E = 0;
reg F = 0;
reg G = 0;

always@(posedge clk or posedge rst)
	if(rst) segments <= 0;
	else segments <= n_segments;

always@(*)begin
	
	A = 0;
	B = 0;
	C = 0;
	D = 0;
	E = 0;
	F = 0;
	G = 0;
	
	if(ena)
		case(number)
			1:begin
				A = 1; B = 1; C = 1; D = 1; E = 1; F = 1; G = 0;
			end
			2:begin
				A = 0; B = 1; C = 1; D = 0; E = 0; F = 0; G = 0;
			end
			3:begin
				A = 1; B = 1; C = 0; D = 1; E = 1; F = 0; G = 1;
			end
			4:begin
				A = 1; B = 1; C = 1; D = 1; E = 0; F = 0; G = 1;
			end
			5:begin
				A = 0; B = 1; C = 1; D = 0; E = 0; F = 1; G = 0;
			end
			6:begin
				A = 1; B = 0; C = 1; D = 1; E = 0; F = 1; G = 1;
			end
			7:begin
				A = 1; B = 0; C = 1; D = 1; E = 1; F = 1; G = 1;
			end
			8:begin
				A = 1; B = 1; C = 1; D = 0; E = 0; F = 0; G = 0;
			end
			9:begin
				A = 1; B = 1; C = 1; D = 1; E = 1; F = 1; G = 1;
			end
			10:begin
				A = 1; B = 1; C = 0; D = 1; E = 0; F = 1; G = 1;
			end
			default:;
		endcase
		
	n_segments = {A,B,C,D,E,F,G,dot};
end

endmodule

module sD_avalon_interface #(
	parameter LEN = 4,
	parameter CHAR_LEN = 5
)(

	input csi_clk,
	input rsi_reset_n,
	
	input avs_s0_write,
	input avs_s0_read,
	input[3:0] avs_s0_address,
	input[31:0] avs_s0_writedata,
	
	output reg[31:0] avs_s0_readdata,
	
	output[CHAR_LEN - 1:0] number1,
	output[CHAR_LEN - 1:0] number2,
	output[CHAR_LEN - 1:0] number3,
	output[CHAR_LEN - 1:0] number4,
	
	output dot1,
	output dot2,
	output dot3,
	output dot4,
	
	output ena
);

reg[CHAR_LEN - 1:0] f_numbers[LEN - 1:0];
reg[CHAR_LEN - 1:0] n_numbers[LEN - 1:0];

reg[CHAR_LEN - 1:0] f_dot;
reg[CHAR_LEN - 1:0] n_dot;

reg f_ena;
reg n_ena;

integer n = 0;

always@(posedge csi_clk or rsi_reset_n)
	if(rsi_reset_n)begin
		for(n=0;n< CHAR_LEN; n = n + 1) begin
			f_numbers[n] <= 0;
			f_dot[n] <= 0;
		end
		f_ena <= 0;
	end else
	begin
		for(n=0;n< CHAR_LEN; n = n + 1) begin
			f_numbers[n] <= n_numbers[n];
			f_dot[n] <= n_dot[n];
		end
		f_ena <= n_ena;
	end
	
always@(*)begin
	avs_s0_readdata = 0;

	if(avs_s0_read) begin
	
		case(avs_s0_address)
			4'h0: avs_s0_readdata = 32'd64;
			4'h1: avs_s0_readdata = f_numbers[0];
			4'h2: avs_s0_readdata = f_numbers[1];
			4'h3: avs_s0_readdata = f_numbers[2];
			4'h4: avs_s0_readdata = f_numbers[3];
			4'h5: avs_s0_readdata = f_dot[0];
			4'h6: avs_s0_readdata = f_dot[1];
			4'h7: avs_s0_readdata = f_dot[2];
			4'h8: avs_s0_readdata = f_dot[3];
			4'h9: avs_s0_readdata = f_ena;
			default: avs_s0_readdata = 32'hFFFFFFFF;
		endcase
	end
	
end

always@(*)begin
	
	n_ena = f_ena;
	
	for(n=0;n< CHAR_LEN; n = n + 1) begin
		n_numbers[n] = f_numbers[n];
		n_dot[n] = f_dot[n];
	end
	
	if(avs_s0_write)begin
		case(avs_s0_address)
			4'h1: n_numbers[0] = avs_s0_writedata;
			4'h2: n_numbers[1] = avs_s0_writedata;
			4'h3: n_numbers[2] = avs_s0_writedata;
			4'h4: n_numbers[3] = avs_s0_writedata;
			4'h5: n_dot[0] = avs_s0_writedata;
			4'h6: n_dot[1] = avs_s0_writedata;
			4'h7: n_dot[2] = avs_s0_writedata;
			4'h8: n_dot[3] = avs_s0_writedata;
			4'h9: n_ena = avs_s0_writedata;
			default:;
		endcase
	end
	
end

assign number1 = f_numbers[0];
assign number2 = f_numbers[1];
assign number3 = f_numbers[2];
assign number4 = f_numbers[3];
	
assign dot1 = f_dot[0];
assign dot2 = f_dot[1];
assign dot3 = f_dot[2];
assign dot4 = f_dot[3];
	
assign ena = f_ena;
	
endmodule
