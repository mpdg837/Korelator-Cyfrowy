
Conclover.elf:     file format elf32-littlenios2
Conclover.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000020

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00000eb8 memsz 0x00000eb8 flags r-x
    LOAD off    0x00001ed8 vaddr 0x00000ed8 paddr 0x00000ef4 align 2**12
         filesz 0x0000001c memsz 0x0000001c flags rw-
    LOAD off    0x00001f10 vaddr 0x00000f10 paddr 0x00000f10 align 2**12
         filesz 0x00000000 memsz 0x0000139c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00000020  00000020  00001ef4  2**0
                  CONTENTS
  2 .text         00000dc8  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000f0  00000de8  00000de8  00001de8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000001c  00000ed8  00000ef4  00001ed8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000139c  00000f10  00000f10  00001f10  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  000022ac  000022ac  00001ef4  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00001ef4  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000250  00000000  00000000  00001f18  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00001dc2  00000000  00000000  00002168  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000f51  00000000  00000000  00003f2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00000b73  00000000  00000000  00004e7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000578  00000000  00000000  000059f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000a51  00000000  00000000  00005f68  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00001389  00000000  00000000  000069b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  00007d44  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000001e8  00000000  00000000  00007d58  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00009242  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  00009245  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00009248  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00009249  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000a  00000000  00000000  0000924a  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000a  00000000  00000000  00009254  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000a  00000000  00000000  0000925e  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000008  00000000  00000000  00009268  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000000e  00000000  00000000  00009270  2**0
                  CONTENTS, READONLY
 26 .jdi          000044c7  00000000  00000000  0000927e  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     00047c6c  00000000  00000000  0000d745  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
00000020 l    d  .exceptions	00000000 .exceptions
00000020 l    d  .text	00000000 .text
00000de8 l    d  .rodata	00000000 .rodata
00000ed8 l    d  .rwdata	00000000 .rwdata
00000f10 l    d  .bss	00000000 .bss
000022ac l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Conclover_bsp//obj/HAL/src/crt0.o
00000058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 conclover.c
00000000 l    df *ABS*	00000000 display_stdio.c
00000000 l    df *ABS*	00000000 keys.c
00000000 l    df *ABS*	00000000 timer.c
00000000 l    df *ABS*	00000000 uart_receiver.c
00000000 l    df *ABS*	00000000 uart_transmitter.c
00000000 l    df *ABS*	00000000 debug.c
00000000 l    df *ABS*	00000000 memory.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000d88 g     F .text	0000002c alt_main
00000ef4 g       *ABS*	00000000 __flash_rwdata_start
00000a90 g     F .text	00000020 pause
000004fc g     F .text	00000014 display_set_freq
000007fc g     F .text	00000010 set_timer
0000033c g     F .text	00000048 conclove
00000de0 g     F .text	00000008 altera_nios2_gen2_irq_init
00000000 g     F .entry	0000000c __reset
00000020 g       *ABS*	00000000 __flash_exceptions_start
000007dc g     F .text	00000010 reset_timer
00000f18 g     O .bss	00000004 alt_argv
00008eea g       *ABS*	00000000 _gp
000007ec g     F .text	00000010 get_time
00000f10 g     O .bss	00000004 display_buffer
0000073c g     F .text	00000030 is_pressed
0000076c g     F .text	00000028 detect_pressed_key
000001b4 g     F .text	0000005c startup
00000bc4 g     F .text	00000064 .hidden __udivsi3
0000005c g     F .text	00000020 formFramesToKM
00000468 g     F .text	00000030 display_load_buffer
00000820 g     F .text	000000a0 receiveSinglePacket
000002ec g     F .text	00000050 concloverSetValues
000022ac g       *ABS*	00000000 __bss_end
00000ef0 g     O .rwdata	00000004 Debug_UART
00000794 g     F .text	00000020 wait_for_press
0000062c g     F .text	00000048 display_printf
00000684 g     F .text	000000b8 display_put_number
0000040c g     F .text	0000002c add_to_buffer
00000438 g     F .text	00000030 display_putpartchar
00000dd8 g     F .text	00000004 alt_dcache_flush_all
000007b4 g     F .text	00000028 wait_for_press_key
00000ef4 g       *ABS*	00000000 __ram_rwdata_end
00000ed8 g       *ABS*	00000000 __ram_rodata_end
00000c28 g     F .text	00000058 .hidden __umodsi3
000022ac g       *ABS*	00000000 end
00004000 g       *ABS*	00000000 __alt_stack_pointer
0000080c g     F .text	00000014 wait
00000020 g     F .text	0000003c _start
00000ed8 g     O .rwdata	00000012 signal
00000dd4 g     F .text	00000004 alt_sys_init
00000a64 g     F .text	0000002c printviau
00000f20 g     O .bss	0000138c buffer
00000c80 g     F .text	00000028 .hidden __mulsi3
00000ed8 g       *ABS*	00000000 __ram_rwdata_start
00000de8 g       *ABS*	00000000 __ram_rodata_start
00000674 g     F .text	00000010 display_abs
000022ac g       *ABS*	00000000 __alt_stack_base
00000974 g     F .text	00000074 beginReceiver
00000f10 g       *ABS*	00000000 __bss_start
00000eec g     O .rwdata	00000004 wiad
00000210 g     F .text	000000dc main
00000000 g       *ABS*	00000000 __alt_mem_RAM
00000f14 g     O .bss	00000004 alt_envp
000008c0 g     F .text	000000b4 receiveTiming
00000ab0 g     F .text	0000001c cleanBuffer
00000acc g     F .text	00000084 .hidden __divsi3
00000de8 g       *ABS*	00000000 __flash_rodata_start
000009f8 g     F .text	0000006c sendIt
00000db4 g     F .text	00000020 alt_irq_init
000004b0 g     F .text	0000004c display_set_lightness
00000f1c g     O .bss	00000004 alt_argc
000009f4 g     F .text	00000004 receive
00000510 g     F .text	0000001c display_put_dot
00000020 g       *ABS*	00000000 __ram_exceptions_start
00000560 g     F .text	00000044 display_clear
0000007c g     F .text	000000ec con
00000ef4 g       *ABS*	00000000 _edata
000022ac g       *ABS*	00000000 _end
00000020 g       *ABS*	00000000 __ram_exceptions_end
0000052c g     F .text	00000018 display_remove_dot
00000b50 g     F .text	00000074 .hidden __modsi3
00004000 g       *ABS*	00000000 __alt_data_end
0000000c g       .entry	00000000 _exit
000005a4 g     F .text	00000088 display_putchar
00000498 g     F .text	00000018 display_set_tube_lightness
00000384 g     F .text	00000088 display_displaychar
000009e8 g     F .text	0000000c closeReceiver
00000ddc g     F .text	00000004 alt_icache_flush_all
00000544 g     F .text	0000001c diplay_wait_for_refresh
00000168 g     F .text	0000004c receivePacket
00000ca8 g     F .text	000000e0 alt_load



Disassembly of section .entry:

00000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   0:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
   4:	08400814 	ori	at,at,32
    jmp r1
   8:	0800683a 	jmp	at

0000000c <_exit>:
	...

Disassembly of section .text:

00000020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  20:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
  24:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
  28:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
  2c:	d6a3ba94 	ori	gp,gp,36586
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  30:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
  34:	1083c414 	ori	r2,r2,3856

    movhi r3, %hi(__bss_end)
  38:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
  3c:	18c8ab14 	ori	r3,r3,8876

    beq r2, r3, 1f
  40:	10c00326 	beq	r2,r3,50 <_start+0x30>

0:
    stw zero, (r2)
  44:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  48:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  4c:	10fffd36 	bltu	r2,r3,44 <_gp+0xffff715a>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  50:	0000ca80 	call	ca8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  54:	0000d880 	call	d88 <alt_main>

00000058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  58:	003fff06 	br	58 <_gp+0xffff716e>

0000005c <formFramesToKM>:

#define MEASURE_LEN 5000
#define LENGTHPERMICROSECOND 0x4CC
#define CONCLOVE_SIZE_LEN 20

int formFramesToKM(int nmax){
  5c:	deffff04 	addi	sp,sp,-4
	int length = nmax * LENGTHPERMICROSECOND;
	return length >> 13;
  60:	01413304 	movi	r5,1228

#define MEASURE_LEN 5000
#define LENGTHPERMICROSECOND 0x4CC
#define CONCLOVE_SIZE_LEN 20

int formFramesToKM(int nmax){
  64:	dfc00015 	stw	ra,0(sp)
	int length = nmax * LENGTHPERMICROSECOND;
	return length >> 13;
  68:	0000c800 	call	c80 <__mulsi3>
}
  6c:	1005d37a 	srai	r2,r2,13
  70:	dfc00017 	ldw	ra,0(sp)
  74:	dec00104 	addi	sp,sp,4
  78:	f800283a 	ret

0000007c <con>:


int con(int* buffer){
  7c:	defffd04 	addi	sp,sp,-12
  80:	dc400115 	stw	r17,4(sp)

	  set_timer(1, 0);
  84:	000b883a 	mov	r5,zero
	int length = nmax * LENGTHPERMICROSECOND;
	return length >> 13;
}


int con(int* buffer){
  88:	2023883a 	mov	r17,r4

	  set_timer(1, 0);
  8c:	01000044 	movi	r4,1
	int length = nmax * LENGTHPERMICROSECOND;
	return length >> 13;
}


int con(int* buffer){
  90:	dfc00215 	stw	ra,8(sp)
  94:	dc000015 	stw	r16,0(sp)

	  set_timer(1, 0);
  98:	00007fc0 	call	7fc <set_timer>

	  char* memc = (char*)buffer;
	  memc ++;
  9c:	8c000044 	addi	r16,r17,1

	  conclove(memc,memc,MEASURE_LEN - 1);
  a0:	800b883a 	mov	r5,r16
  a4:	0184e1c4 	movi	r6,4999
  a8:	8009883a 	mov	r4,r16
  ac:	000033c0 	call	33c <conclove>
	  int time = get_time(1);
  b0:	01000044 	movi	r4,1
  b4:	00007ec0 	call	7ec <get_time>

	  printviau("Pomiar zakonczony: \r\n");
  b8:	01000034 	movhi	r4,0
  bc:	21037a04 	addi	r4,r4,3560
  c0:	0000a640 	call	a64 <printviau>
  c4:	00fffac4 	movi	r3,-21
  c8:	800b883a 	mov	r5,r16
  cc:	8a04e204 	addi	r8,r17,5000

	  int nmax = 0;
	  unsigned char maxval = 0;
	  unsigned long sum = 0;
  d0:	0009883a 	mov	r4,zero
	  int time = get_time(1);

	  printviau("Pomiar zakonczony: \r\n");

	  int nmax = 0;
	  unsigned char maxval = 0;
  d4:	0005883a 	mov	r2,zero
	  conclove(memc,memc,MEASURE_LEN - 1);
	  int time = get_time(1);

	  printviau("Pomiar zakonczony: \r\n");

	  int nmax = 0;
  d8:	0021883a 	mov	r16,zero
  dc:	1c47c83a 	sub	r3,r3,r17
	  unsigned char maxval = 0;
	  unsigned long sum = 0;

	  for(int n=0;n<MEASURE_LEN - 1;n++){
		  sum += memc[n];
  e0:	29800003 	ldbu	r6,0(r5)

		  if(maxval < memc[n]){
  e4:	12403fcc 	andi	r9,r2,255
	  int nmax = 0;
	  unsigned char maxval = 0;
	  unsigned long sum = 0;

	  for(int n=0;n<MEASURE_LEN - 1;n++){
		  sum += memc[n];
  e8:	31c03fcc 	andi	r7,r6,255
  ec:	39c0201c 	xori	r7,r7,128
  f0:	39ffe004 	addi	r7,r7,-128
  f4:	21c9883a 	add	r4,r4,r7

		  if(maxval < memc[n]){
  f8:	49c0020e 	bge	r9,r7,104 <con+0x88>
  fc:	1961883a 	add	r16,r3,r5
			  nmax = n - 1 - (CONCLOVE_SIZE_LEN - 1);
			  maxval = memc[n];
 100:	3005883a 	mov	r2,r6
 104:	29400044 	addi	r5,r5,1

	  int nmax = 0;
	  unsigned char maxval = 0;
	  unsigned long sum = 0;

	  for(int n=0;n<MEASURE_LEN - 1;n++){
 108:	2a3ff51e 	bne	r5,r8,e0 <_gp+0xffff71f6>
	  }
	  sum = sum / (MEASURE_LEN - 1);

	  int wsp = maxval/sum;

	  if(wsp > 10 && nmax >= 0) {
 10c:	0144e1c4 	movi	r5,4999
 110:	14403fcc 	andi	r17,r2,255
 114:	0000bc40 	call	bc4 <__udivsi3>
 118:	100b883a 	mov	r5,r2
 11c:	8809883a 	mov	r4,r17
 120:	0000bc40 	call	bc4 <__udivsi3>
 124:	00c00284 	movi	r3,10
 128:	1880060e 	bge	r3,r2,144 <con+0xc8>
 12c:	80000516 	blt	r16,zero,144 <con+0xc8>
		  printviau("Wykryto powrot sygnalu \r\n");
 130:	01000034 	movhi	r4,0
 134:	21038004 	addi	r4,r4,3584
 138:	0000a640 	call	a64 <printviau>

		  return nmax;
 13c:	8005883a 	mov	r2,r16
 140:	00000406 	br	154 <con+0xd8>
	  }
	  else {
		  printviau("Blad w pomiarze \r\n");
 144:	01000034 	movhi	r4,0
 148:	21038704 	addi	r4,r4,3612
 14c:	0000a640 	call	a64 <printviau>
		  return -1;
 150:	00bfffc4 	movi	r2,-1
	  }
}
 154:	dfc00217 	ldw	ra,8(sp)
 158:	dc400117 	ldw	r17,4(sp)
 15c:	dc000017 	ldw	r16,0(sp)
 160:	dec00304 	addi	sp,sp,12
 164:	f800283a 	ret

00000168 <receivePacket>:
#define MAX_RECEIVED_MESSAGE_LEN 128
#define MAX_RECEIVE_TIME_OUT 120

#define LENGTHPERMICROSECOND 0x4CC

void receivePacket(int* buffer){
 168:	deffdf04 	addi	sp,sp,-132

	beginReceiver(buffer,BUFFER_RECEIVER_LEN);
 16c:	0144e304 	movi	r5,5004
#define MAX_RECEIVED_MESSAGE_LEN 128
#define MAX_RECEIVE_TIME_OUT 120

#define LENGTHPERMICROSECOND 0x4CC

void receivePacket(int* buffer){
 170:	dfc02015 	stw	ra,128(sp)

	beginReceiver(buffer,BUFFER_RECEIVER_LEN);
 174:	00009740 	call	974 <beginReceiver>
	char received[MAX_RECEIVED_MESSAGE_LEN];

	printviau("Czekam na sygnal ... \r\n");
 178:	01000034 	movhi	r4,0
 17c:	21038c04 	addi	r4,r4,3632
 180:	0000a640 	call	a64 <printviau>

	display_clear();
 184:	00005600 	call	560 <display_clear>
	display_printf("wai\n");
 188:	01000034 	movhi	r4,0
 18c:	21039204 	addi	r4,r4,3656
 190:	000062c0 	call	62c <display_printf>

	while(1){
		if(receive(received,MAX_RECEIVED_MESSAGE_LEN)){
 194:	01402004 	movi	r5,128
 198:	d809883a 	mov	r4,sp
 19c:	00009f40 	call	9f4 <receive>
 1a0:	103ffc26 	beq	r2,zero,194 <_gp+0xffff72aa>
			closeReceiver();
 1a4:	00009e80 	call	9e8 <closeReceiver>
			break;
		}
	}
}
 1a8:	dfc02017 	ldw	ra,128(sp)
 1ac:	dec02104 	addi	sp,sp,132
 1b0:	f800283a 	ret

000001b4 <startup>:
int buffer[BUFFER_RECEIVER_LEN / sizeof(int)];

char signal[] = {0,39,75,103,121,127,121,75,39,-39,-75,-103,-121,-127,-121,-103,-75,-39};


void startup(void){
 1b4:	deffff04 	addi	sp,sp,-4
 1b8:	dfc00015 	stw	ra,0(sp)
	  display_clear();
 1bc:	00005600 	call	560 <display_clear>

	  beginReceiver(buffer,BUFFER_RECEIVER_LEN);
 1c0:	01000034 	movhi	r4,0
 1c4:	0144e304 	movi	r5,5004
 1c8:	2103c804 	addi	r4,r4,3872
 1cc:	00009740 	call	974 <beginReceiver>
	  concloverSetValues(signal);
 1d0:	01000034 	movhi	r4,0
 1d4:	2103b604 	addi	r4,r4,3800
 1d8:	00002ec0 	call	2ec <concloverSetValues>

	  printviau("Korelator Cyfrowy 1.0 \r\n");
 1dc:	01000034 	movhi	r4,0
 1e0:	21039404 	addi	r4,r4,3664
 1e4:	0000a640 	call	a64 <printviau>
	  printviau("Sprzet wlaczony. Czekam na dalsza aktywnosc. Wcisnij przycisk 1 aby kontynuowac\r\n");
 1e8:	01000034 	movhi	r4,0
 1ec:	21039b04 	addi	r4,r4,3692
 1f0:	0000a640 	call	a64 <printviau>
	  printviau("===\r\n");
 1f4:	01000034 	movhi	r4,0
 1f8:	2103b004 	addi	r4,r4,3776
 1fc:	0000a640 	call	a64 <printviau>

	  display_set_lightness(7);
 200:	010001c4 	movi	r4,7


}
 204:	dfc00017 	ldw	ra,0(sp)
 208:	dec00104 	addi	sp,sp,4

	  printviau("Korelator Cyfrowy 1.0 \r\n");
	  printviau("Sprzet wlaczony. Czekam na dalsza aktywnosc. Wcisnij przycisk 1 aby kontynuowac\r\n");
	  printviau("===\r\n");

	  display_set_lightness(7);
 20c:	00004b01 	jmpi	4b0 <display_set_lightness>

00000210 <main>:
}



int main()
{
 210:	defffa04 	addi	sp,sp,-24
 214:	dcc00315 	stw	r19,12(sp)
 218:	dfc00515 	stw	ra,20(sp)
 21c:	dd000415 	stw	r20,16(sp)
 220:	dc800215 	stw	r18,8(sp)
 224:	dc400115 	stw	r17,4(sp)
 228:	dc000015 	stw	r16,0(sp)
	  int i = is_pressed(KEYS_KEY2);
	  int j = is_pressed(KEYS_KEY1);

	  display_clear();

	  if(nmax == -1){
 22c:	04ffffc4 	movi	r19,-1



int main()
{
  startup();
 230:	00001b40 	call	1b4 <startup>


  while(1){
	  display_clear();
 234:	00005600 	call	560 <display_clear>
	  display_printf("pres\n");
 238:	01000034 	movhi	r4,0
 23c:	2103b204 	addi	r4,r4,3784
 240:	000062c0 	call	62c <display_printf>

	  pause();
 244:	0000a900 	call	a90 <pause>

	  receivePacket(buffer);
 248:	01000034 	movhi	r4,0
 24c:	2103c804 	addi	r4,r4,3872
 250:	00001680 	call	168 <receivePacket>

	  int nmax = con(buffer);
 254:	01000034 	movhi	r4,0
 258:	2103c804 	addi	r4,r4,3872
 25c:	000007c0 	call	7c <con>
#define LENGTHPERMICROSECOND 0x4CC
#define CONCLOVE_SIZE_LEN 20

int formFramesToKM(int nmax){
	int length = nmax * LENGTHPERMICROSECOND;
	return length >> 13;
 260:	01413304 	movi	r5,1228
 264:	1009883a 	mov	r4,r2
 268:	1025883a 	mov	r18,r2
 26c:	0000c800 	call	c80 <__mulsi3>

	  int length = formFramesToKM(nmax);

	  int i = is_pressed(KEYS_KEY2);
 270:	01000044 	movi	r4,1
 274:	1029d37a 	srai	r20,r2,13
 278:	000073c0 	call	73c <is_pressed>
	  int j = is_pressed(KEYS_KEY1);
 27c:	0009883a 	mov	r4,zero
 280:	000073c0 	call	73c <is_pressed>

	  display_clear();
 284:	00005600 	call	560 <display_clear>

	  if(nmax == -1){
 288:	94c0041e 	bne	r18,r19,29c <main+0x8c>
		  display_printf("err\n");
 28c:	01000034 	movhi	r4,0
 290:	2103b404 	addi	r4,r4,3792
 294:	000062c0 	call	62c <display_printf>
 298:	003fe606 	br	234 <_gp+0xffff734a>
 29c:	04400044 	movi	r17,1
 2a0:	0021883a 	mov	r16,zero
		  int status = 0;
		  int change = 1;

		  while(1){

			  if(change){
 2a4:	88000626 	beq	r17,zero,2c0 <main+0xb0>
				  display_clear();
 2a8:	00005600 	call	560 <display_clear>
				  if(status) display_put_number(length);
 2ac:	80000226 	beq	r16,zero,2b8 <main+0xa8>
 2b0:	a009883a 	mov	r4,r20
 2b4:	00000106 	br	2bc <main+0xac>
				  else display_put_number(nmax);
 2b8:	9009883a 	mov	r4,r18
 2bc:	00006840 	call	684 <display_put_number>
				  change = 0;
			  }

			  if(is_pressed(KEYS_KEY2)) {
 2c0:	01000044 	movi	r4,1
 2c4:	000073c0 	call	73c <is_pressed>
 2c8:	10000326 	beq	r2,zero,2d8 <main+0xc8>
 2cc:	8400005c 	xori	r16,r16,1
				  if(!status) status = 1;
				  else status = 0;
				  change = 1;
 2d0:	04400044 	movi	r17,1
 2d4:	00000106 	br	2dc <main+0xcc>
 2d8:	0023883a 	mov	r17,zero
			  }

			  if(is_pressed(KEYS_KEY1)){
 2dc:	0009883a 	mov	r4,zero
 2e0:	000073c0 	call	73c <is_pressed>
 2e4:	103fef26 	beq	r2,zero,2a4 <_gp+0xffff73ba>
 2e8:	003fd206 	br	234 <_gp+0xffff734a>

000002ec <concloverSetValues>:

void concloverSetValues(char* signal){

	int* wsk = SIGNAL_VALUES;

	for(int n=0;n<5;n++){
 2ec:	000f883a 	mov	r7,zero
#include "./conclover_connection.c"

void concloverSetValues(char* signal){

	int* wsk = SIGNAL_VALUES;
 2f0:	009c4804 	movi	r2,28960

	for(int n=0;n<5;n++){
		for(int k=3;k>=0;k--){
 2f4:	023fffc4 	movi	r8,-1

void concloverSetValues(char* signal){

	int* wsk = SIGNAL_VALUES;

	for(int n=0;n<5;n++){
 2f8:	025c4d04 	movi	r9,28980
		for(int k=3;k>=0;k--){
			*wsk = (*wsk << 8) | ((unsigned char)signal[(n << 2) + k]);
 2fc:	39c7883a 	add	r3,r7,r7
 300:	18cd883a 	add	r6,r3,r3
 304:	014000c4 	movi	r5,3
 308:	2987883a 	add	r3,r5,r6
 30c:	20c7883a 	add	r3,r4,r3
 310:	1a800003 	ldbu	r10,0(r3)
 314:	10c00017 	ldw	r3,0(r2)
void concloverSetValues(char* signal){

	int* wsk = SIGNAL_VALUES;

	for(int n=0;n<5;n++){
		for(int k=3;k>=0;k--){
 318:	297fffc4 	addi	r5,r5,-1
			*wsk = (*wsk << 8) | ((unsigned char)signal[(n << 2) + k]);
 31c:	1806923a 	slli	r3,r3,8
 320:	50c6b03a 	or	r3,r10,r3
 324:	10c00015 	stw	r3,0(r2)
void concloverSetValues(char* signal){

	int* wsk = SIGNAL_VALUES;

	for(int n=0;n<5;n++){
		for(int k=3;k>=0;k--){
 328:	2a3ff71e 	bne	r5,r8,308 <_gp+0xffff741e>
			*wsk = (*wsk << 8) | ((unsigned char)signal[(n << 2) + k]);
		}
		wsk++;
 32c:	10800104 	addi	r2,r2,4

void concloverSetValues(char* signal){

	int* wsk = SIGNAL_VALUES;

	for(int n=0;n<5;n++){
 330:	39c00044 	addi	r7,r7,1
 334:	127ff11e 	bne	r2,r9,2fc <_gp+0xffff7412>
 338:	f800283a 	ret

0000033c <conclove>:
		wsk++;
	}
}

void conclove(char* values, char* output, int len){
	*START_LOAD_ADDR = &values[0];
 33c:	009c4104 	movi	r2,28932
	*STOP_LOAD_ADDR = &values[len - 1];
 340:	31bfffc4 	addi	r6,r6,-1
		wsk++;
	}
}

void conclove(char* values, char* output, int len){
	*START_LOAD_ADDR = &values[0];
 344:	11000015 	stw	r4,0(r2)
	*STOP_LOAD_ADDR = &values[len - 1];
 348:	2189883a 	add	r4,r4,r6
 34c:	009c4204 	movi	r2,28936
 350:	11000015 	stw	r4,0(r2)
	*START_SAVE_ADDR = &output[0];
 354:	009c4504 	movi	r2,28948
 358:	11400015 	stw	r5,0(r2)
	*STOP_SAVE_ADDR = &output[len - 1];
 35c:	298d883a 	add	r6,r5,r6
 360:	009c4604 	movi	r2,28952
 364:	11800015 	stw	r6,0(r2)

	*START_CONCLOVE = 1;
 368:	00dc4404 	movi	r3,28944
 36c:	00800044 	movi	r2,1
 370:	18800015 	stw	r2,0(r3)
	while(*WORK_CONCLOVE == 1);
 374:	011c4304 	movi	r4,28940
 378:	20c00017 	ldw	r3,0(r4)
 37c:	18bffe26 	beq	r3,r2,378 <_gp+0xffff748e>
}
 380:	f800283a 	ret

00000384 <display_displaychar>:

}

void display_displaychar(char character){

	if(character == '-') display_buffer[3] = 38;
 384:	20803fcc 	andi	r2,r4,255
 388:	1080201c 	xori	r2,r2,128
 38c:	10bfe004 	addi	r2,r2,-128
 390:	00c00b44 	movi	r3,45
 394:	10c0031e 	bne	r2,r3,3a4 <display_displaychar+0x20>
 398:	00800984 	movi	r2,38
 39c:	d0a00a45 	stb	r2,-32727(gp)
 3a0:	f800283a 	ret
	else if(character == ' ') display_buffer[3] = 0;
 3a4:	00c00804 	movi	r3,32
 3a8:	10c0021e 	bne	r2,r3,3b4 <display_displaychar+0x30>
 3ac:	d0200a45 	stb	zero,-32727(gp)
 3b0:	f800283a 	ret
	else if(character >= '0' && character <= '9') display_buffer[3] = character - '0' + DISPLAY_NUMBER_SHIFT;
 3b4:	20bff404 	addi	r2,r4,-48
 3b8:	10803fcc 	andi	r2,r2,255
 3bc:	00c00244 	movi	r3,9
 3c0:	18800236 	bltu	r3,r2,3cc <display_displaychar+0x48>
 3c4:	213ff444 	addi	r4,r4,-47
 3c8:	00000b06 	br	3f8 <display_displaychar+0x74>
	else if(character >= 'A' && character <= 'Z') display_buffer[3] = character - 'A' + DISPLAY_LETTER_SHIFT;
 3cc:	20bfefc4 	addi	r2,r4,-65
 3d0:	10803fcc 	andi	r2,r2,255
 3d4:	00c00644 	movi	r3,25
 3d8:	18800236 	bltu	r3,r2,3e4 <display_displaychar+0x60>
 3dc:	213ff284 	addi	r4,r4,-54
 3e0:	00000506 	br	3f8 <display_displaychar+0x74>
	else if(character >= 'a' && character <= '}') display_buffer[3] = character - 'a' + DISPLAY_LETTER_SHIFT;
 3e4:	20bfe7c4 	addi	r2,r4,-97
 3e8:	10803fcc 	andi	r2,r2,255
 3ec:	00c00704 	movi	r3,28
 3f0:	18800336 	bltu	r3,r2,400 <display_displaychar+0x7c>
 3f4:	213fea84 	addi	r4,r4,-86
 3f8:	d1200a45 	stb	r4,-32727(gp)
 3fc:	f800283a 	ret
	else *DISPLAY_CHARACTER4 = 0;
 400:	00980404 	movi	r2,24592
 404:	10000015 	stw	zero,0(r2)
 408:	f800283a 	ret

0000040c <add_to_buffer>:
char display_buffer[4];

void add_to_buffer(char character){
	 for(int n=0; n < 4 ; n++){

		if(n != 0) display_buffer[n-1] = display_buffer[n];
 40c:	d0a00984 	addi	r2,gp,-32730
 410:	10c00043 	ldbu	r3,1(r2)

	 }

	 display_displaychar(character);
 414:	21003fcc 	andi	r4,r4,255
 418:	2100201c 	xori	r4,r4,128
char display_buffer[4];

void add_to_buffer(char character){
	 for(int n=0; n < 4 ; n++){

		if(n != 0) display_buffer[n-1] = display_buffer[n];
 41c:	10c00005 	stb	r3,0(r2)
 420:	10c00083 	ldbu	r3,2(r2)

	 }

	 display_displaychar(character);
 424:	213fe004 	addi	r4,r4,-128
char display_buffer[4];

void add_to_buffer(char character){
	 for(int n=0; n < 4 ; n++){

		if(n != 0) display_buffer[n-1] = display_buffer[n];
 428:	10c00045 	stb	r3,1(r2)
 42c:	10c000c3 	ldbu	r3,3(r2)
 430:	10c00085 	stb	r3,2(r2)

	 }

	 display_displaychar(character);
 434:	00003841 	jmpi	384 <display_displaychar>

00000438 <display_putpartchar>:
}
void display_putpartchar(char character){

	if(*DISPLAY_IDENTITY == DISPLAY_IDENTITY_VALUE){
 438:	00980004 	movi	r2,24576
 43c:	10c00017 	ldw	r3,0(r2)
 440:	00801004 	movi	r2,64
 444:	1880071e 	bne	r3,r2,464 <display_putpartchar+0x2c>

		*DISPLAY_ENABLED = TRUE_M;
		add_to_buffer(character);
 448:	21003fcc 	andi	r4,r4,255
 44c:	2100201c 	xori	r4,r4,128
}
void display_putpartchar(char character){

	if(*DISPLAY_IDENTITY == DISPLAY_IDENTITY_VALUE){

		*DISPLAY_ENABLED = TRUE_M;
 450:	00c00044 	movi	r3,1
 454:	00980904 	movi	r2,24612
		add_to_buffer(character);
 458:	213fe004 	addi	r4,r4,-128
}
void display_putpartchar(char character){

	if(*DISPLAY_IDENTITY == DISPLAY_IDENTITY_VALUE){

		*DISPLAY_ENABLED = TRUE_M;
 45c:	10c00015 	stw	r3,0(r2)
		add_to_buffer(character);
 460:	000040c1 	jmpi	40c <add_to_buffer>
 464:	f800283a 	ret

00000468 <display_load_buffer>:


void display_load_buffer(){
	int n=0;
	for(int* analysed = DISPLAY_CHARACTER1 ; analysed <= DISPLAY_CHARACTER4; analysed++){
		*analysed = display_buffer[n];
 468:	d0a00984 	addi	r2,gp,-32730
 46c:	11000007 	ldb	r4,0(r2)
 470:	00d80104 	movi	r3,24580
 474:	19000015 	stw	r4,0(r3)
 478:	11000047 	ldb	r4,1(r2)
 47c:	00d80204 	movi	r3,24584
 480:	19000015 	stw	r4,0(r3)
 484:	11000087 	ldb	r4,2(r2)
 488:	19000115 	stw	r4,4(r3)
 48c:	108000c7 	ldb	r2,3(r2)
 490:	18800215 	stw	r2,8(r3)
 494:	f800283a 	ret

00000498 <display_set_tube_lightness>:
		n++;
	}
}

void display_set_tube_lightness(int num_tube,int light){
	if(light >=0 && light < DISPLAY_MAX_LIGHT){
 498:	008001c4 	movi	r2,7
 49c:	11400336 	bltu	r2,r5,4ac <display_set_tube_lightness+0x14>
		int* lightness = DISPLAY_LIGHTNESS1;
		lightness += num_tube;

		*lightness = light;
 4a0:	2109883a 	add	r4,r4,r4
 4a4:	2109883a 	add	r4,r4,r4
 4a8:	21580b15 	stw	r5,24620(r4)
 4ac:	f800283a 	ret

000004b0 <display_set_lightness>:
	}

}

void display_set_lightness(int light){
 4b0:	defffc04 	addi	sp,sp,-16
 4b4:	dc800215 	stw	r18,8(sp)
 4b8:	dc400115 	stw	r17,4(sp)
 4bc:	dc000015 	stw	r16,0(sp)
 4c0:	dfc00315 	stw	ra,12(sp)
 4c4:	2025883a 	mov	r18,r4
	for(int n=0;n<DISPLAY_MAX_LEN;n++){
 4c8:	0021883a 	mov	r16,zero
 4cc:	04400104 	movi	r17,4
		display_set_tube_lightness(n,light);
 4d0:	8009883a 	mov	r4,r16
 4d4:	900b883a 	mov	r5,r18
	}

}

void display_set_lightness(int light){
	for(int n=0;n<DISPLAY_MAX_LEN;n++){
 4d8:	84000044 	addi	r16,r16,1
		display_set_tube_lightness(n,light);
 4dc:	00004980 	call	498 <display_set_tube_lightness>
	}

}

void display_set_lightness(int light){
	for(int n=0;n<DISPLAY_MAX_LEN;n++){
 4e0:	847ffb1e 	bne	r16,r17,4d0 <_gp+0xffff75e6>
		display_set_tube_lightness(n,light);
	}
}
 4e4:	dfc00317 	ldw	ra,12(sp)
 4e8:	dc800217 	ldw	r18,8(sp)
 4ec:	dc400117 	ldw	r17,4(sp)
 4f0:	dc000017 	ldw	r16,0(sp)
 4f4:	dec00404 	addi	sp,sp,16
 4f8:	f800283a 	ret

000004fc <display_set_freq>:

void display_set_freq(int freq){
	if(freq >=0 && freq < DISPLAY_MAX_FREQ) *DISPLAY_FREQ = freq;
 4fc:	00800144 	movi	r2,5
 500:	11000236 	bltu	r2,r4,50c <display_set_freq+0x10>
 504:	00980a04 	movi	r2,24616
 508:	11000015 	stw	r4,0(r2)
 50c:	f800283a 	ret

00000510 <display_put_dot>:
}
void display_put_dot(int position){
	int* dotSetter = DISPLAY_DOT4;
	dotSetter -= position;
	*dotSetter = TRUE;
 510:	2109883a 	add	r4,r4,r4
 514:	00980804 	movi	r2,24608
 518:	2109883a 	add	r4,r4,r4
 51c:	1109c83a 	sub	r4,r2,r4
 520:	00800044 	movi	r2,1
 524:	20800015 	stw	r2,0(r4)
 528:	f800283a 	ret

0000052c <display_remove_dot>:
}

void display_remove_dot(int position){
	int* dotSetter = DISPLAY_DOT4;
	dotSetter -= position;
	*dotSetter = FALSE;
 52c:	2109883a 	add	r4,r4,r4
 530:	2109883a 	add	r4,r4,r4
 534:	00980804 	movi	r2,24608
 538:	1109c83a 	sub	r4,r2,r4
 53c:	20000015 	stw	zero,0(r4)
 540:	f800283a 	ret

00000544 <diplay_wait_for_refresh>:
#define DISPLAY_MINIMAL_REFRESH_TIME 8

#include "./display.c"

void diplay_wait_for_refresh(){
	while(*TIMER2_ADDR < DISPLAY_MINIMAL_REFRESH_TIME);
 544:	01182104 	movi	r4,24708
 548:	00c001c4 	movi	r3,7
 54c:	20800017 	ldw	r2,0(r4)
 550:	18bffe0e 	bge	r3,r2,54c <_gp+0xffff7662>
	*TIMER2_ADDR = 0;
 554:	00982104 	movi	r2,24708
 558:	10000015 	stw	zero,0(r2)
 55c:	f800283a 	ret

00000560 <display_clear>:
}

void display_clear(){
 560:	deffff04 	addi	sp,sp,-4
 564:	dfc00015 	stw	ra,0(sp)

	diplay_wait_for_refresh();
 568:	00005440 	call	544 <diplay_wait_for_refresh>

	int* analysed = DISPLAY_CHARACTER1;
	int n=0;
 56c:	0007883a 	mov	r3,zero

void display_clear(){

	diplay_wait_for_refresh();

	int* analysed = DISPLAY_CHARACTER1;
 570:	00980104 	movi	r2,24580
	int n=0;
	for(; analysed <=DISPLAY_CHARACTER4 ; analysed ++){

		display_buffer[n] = 0;
 574:	d1a00984 	addi	r6,gp,-32730

	diplay_wait_for_refresh();

	int* analysed = DISPLAY_CHARACTER1;
	int n=0;
	for(; analysed <=DISPLAY_CHARACTER4 ; analysed ++){
 578:	01180504 	movi	r4,24596

		display_buffer[n] = 0;
 57c:	198b883a 	add	r5,r3,r6
 580:	28000005 	stb	zero,0(r5)
		n++;

		*analysed = 0;
 584:	10000015 	stw	zero,0(r2)
		int* analysedDot = analysed + 4;
		*analysedDot = 0;
 588:	10000415 	stw	zero,16(r2)

	diplay_wait_for_refresh();

	int* analysed = DISPLAY_CHARACTER1;
	int n=0;
	for(; analysed <=DISPLAY_CHARACTER4 ; analysed ++){
 58c:	10800104 	addi	r2,r2,4

		display_buffer[n] = 0;
		n++;
 590:	18c00044 	addi	r3,r3,1

	diplay_wait_for_refresh();

	int* analysed = DISPLAY_CHARACTER1;
	int n=0;
	for(; analysed <=DISPLAY_CHARACTER4 ; analysed ++){
 594:	113ff91e 	bne	r2,r4,57c <_gp+0xffff7692>

		*analysed = 0;
		int* analysedDot = analysed + 4;
		*analysedDot = 0;
	}
}
 598:	dfc00017 	ldw	ra,0(sp)
 59c:	dec00104 	addi	sp,sp,4
 5a0:	f800283a 	ret

000005a4 <display_putchar>:

void display_putchar(char charset){
	switch(charset){
 5a4:	21003fcc 	andi	r4,r4,255
		int* analysedDot = analysed + 4;
		*analysedDot = 0;
	}
}

void display_putchar(char charset){
 5a8:	deffff04 	addi	sp,sp,-4
	switch(charset){
 5ac:	2100201c 	xori	r4,r4,128
		int* analysedDot = analysed + 4;
		*analysedDot = 0;
	}
}

void display_putchar(char charset){
 5b0:	dfc00015 	stw	ra,0(sp)
	switch(charset){
 5b4:	213fe004 	addi	r4,r4,-128
 5b8:	008015c4 	movi	r2,87
 5bc:	20800d26 	beq	r4,r2,5f4 <display_putchar+0x50>
 5c0:	11000516 	blt	r2,r4,5d8 <display_putchar+0x34>
 5c4:	008012c4 	movi	r2,75
 5c8:	20800e26 	beq	r4,r2,604 <display_putchar+0x60>
 5cc:	00801344 	movi	r2,77
 5d0:	20801026 	beq	r4,r2,614 <display_putchar+0x70>
 5d4:	00001206 	br	620 <display_putchar+0x7c>
 5d8:	00801b44 	movi	r2,109
 5dc:	20800d26 	beq	r4,r2,614 <display_putchar+0x70>
 5e0:	00801dc4 	movi	r2,119
 5e4:	20800326 	beq	r4,r2,5f4 <display_putchar+0x50>
 5e8:	00801ac4 	movi	r2,107
 5ec:	20800c1e 	bne	r4,r2,620 <display_putchar+0x7c>
 5f0:	00000406 	br	604 <display_putchar+0x60>
		case 'W':
		case 'w':
			display_putpartchar('u');
 5f4:	01001d44 	movi	r4,117
 5f8:	00004380 	call	438 <display_putpartchar>
			display_putpartchar('w');
 5fc:	01001dc4 	movi	r4,119
 600:	00000706 	br	620 <display_putchar+0x7c>
			break;
		case 'k':
		case 'K':
			display_putpartchar('k');
 604:	01001ac4 	movi	r4,107
 608:	00004380 	call	438 <display_putpartchar>
			display_putpartchar('{');
 60c:	01001ec4 	movi	r4,123
 610:	00000306 	br	620 <display_putchar+0x7c>
			break;
		case 'M':
		case 'm':
			display_putpartchar('n');
 614:	01001b84 	movi	r4,110
 618:	00004380 	call	438 <display_putpartchar>
			display_putpartchar('m');
 61c:	01001b44 	movi	r4,109
			break;
		default:
			display_putpartchar(charset);
			break;
	}
}
 620:	dfc00017 	ldw	ra,0(sp)
 624:	dec00104 	addi	sp,sp,4
		case 'm':
			display_putpartchar('n');
			display_putpartchar('m');
			break;
		default:
			display_putpartchar(charset);
 628:	00004381 	jmpi	438 <display_putpartchar>

0000062c <display_printf>:
			break;
	}
}

void display_printf(char* string){
 62c:	defffd04 	addi	sp,sp,-12
 630:	dc400115 	stw	r17,4(sp)
 634:	dc000015 	stw	r16,0(sp)
 638:	dfc00215 	stw	ra,8(sp)
 63c:	2021883a 	mov	r16,r4
	display_clear();
	int n=0;
	while(string[n] != '\0' && string[n] != '\n'){
 640:	04400284 	movi	r17,10
			break;
	}
}

void display_printf(char* string){
	display_clear();
 644:	00005600 	call	560 <display_clear>
	int n=0;
	while(string[n] != '\0' && string[n] != '\n'){
 648:	81000007 	ldb	r4,0(r16)
 64c:	20000426 	beq	r4,zero,660 <display_printf+0x34>
 650:	84000044 	addi	r16,r16,1
 654:	24400226 	beq	r4,r17,660 <display_printf+0x34>
		display_putchar(string[n]);
 658:	00005a40 	call	5a4 <display_putchar>
 65c:	003ffa06 	br	648 <_gp+0xffff775e>
		n ++;
	}
	display_load_buffer();
}
 660:	dfc00217 	ldw	ra,8(sp)
 664:	dc400117 	ldw	r17,4(sp)
 668:	dc000017 	ldw	r16,0(sp)
 66c:	dec00304 	addi	sp,sp,12
	int n=0;
	while(string[n] != '\0' && string[n] != '\n'){
		display_putchar(string[n]);
		n ++;
	}
	display_load_buffer();
 670:	00004681 	jmpi	468 <display_load_buffer>

00000674 <display_abs>:
}

int display_abs(int number){
 674:	2005883a 	mov	r2,r4
 678:	2000010e 	bge	r4,zero,680 <display_abs+0xc>
 67c:	0105c83a 	sub	r2,zero,r4
	if(number < 0) return -number;
	else return number;
}
 680:	f800283a 	ret

00000684 <display_put_number>:

void display_put_number(int number){
 684:	defffa04 	addi	sp,sp,-24
 688:	dc000115 	stw	r16,4(sp)
 68c:	dfc00515 	stw	ra,20(sp)
 690:	dcc00415 	stw	r19,16(sp)
 694:	dc800315 	stw	r18,12(sp)
 698:	dc400215 	stw	r17,8(sp)
 69c:	2021883a 	mov	r16,r4
	char znaki[DISPLAY_MAX_DISPLAY_LEN];

	if(number < 0)  display_putpartchar('-');
 6a0:	2000030e 	bge	r4,zero,6b0 <display_put_number+0x2c>
 6a4:	01000b44 	movi	r4,45
 6a8:	00004380 	call	438 <display_putpartchar>
	}
	display_load_buffer();
}

int display_abs(int number){
	if(number < 0) return -number;
 6ac:	0421c83a 	sub	r16,zero,r16

	if(number < 0)  display_putpartchar('-');
	number = display_abs(number);

	for(int n=0;n<DISPLAY_MAX_DISPLAY_LEN;n++){
		znaki[n] = '\0';
 6b0:	d8000005 	stb	zero,0(sp)
 6b4:	d8000045 	stb	zero,1(sp)
 6b8:	d8000085 	stb	zero,2(sp)
 6bc:	d80000c5 	stb	zero,3(sp)
 6c0:	0023883a 	mov	r17,zero
	}

	int buffernum = number;
	int n=0;
	while(buffernum != 0){
 6c4:	80000e26 	beq	r16,zero,700 <display_put_number+0x7c>
		int bufferedsinglenum = buffernum / 10;
 6c8:	8009883a 	mov	r4,r16
 6cc:	01400284 	movi	r5,10
 6d0:	0000acc0 	call	acc <__divsi3>
		bufferedsinglenum *= 10;

		char singlenum = (buffernum - bufferedsinglenum) + '0';
		znaki[n] = singlenum;
 6d4:	01400284 	movi	r5,10
 6d8:	1009883a 	mov	r4,r2
	}

	int buffernum = number;
	int n=0;
	while(buffernum != 0){
		int bufferedsinglenum = buffernum / 10;
 6dc:	1025883a 	mov	r18,r2
		bufferedsinglenum *= 10;

		char singlenum = (buffernum - bufferedsinglenum) + '0';
		znaki[n] = singlenum;
 6e0:	84000c04 	addi	r16,r16,48
 6e4:	0000c800 	call	c80 <__mulsi3>
 6e8:	dc67883a 	add	r19,sp,r17
 6ec:	8085c83a 	sub	r2,r16,r2
 6f0:	98800005 	stb	r2,0(r19)

		buffernum /= 10;
		n++;
 6f4:	8c400044 	addi	r17,r17,1
		bufferedsinglenum *= 10;

		char singlenum = (buffernum - bufferedsinglenum) + '0';
		znaki[n] = singlenum;

		buffernum /= 10;
 6f8:	9021883a 	mov	r16,r18
 6fc:	003ff106 	br	6c4 <_gp+0xffff77da>
 700:	040000c4 	movi	r16,3
		n++;
	}

	for(int n=DISPLAY_MAX_DISPLAY_LEN - 1;n>= 0;n--){
 704:	047fffc4 	movi	r17,-1
		if(znaki[n] != '\0') display_putpartchar(znaki[n]);
 708:	dc05883a 	add	r2,sp,r16
 70c:	11000007 	ldb	r4,0(r2)
 710:	20000126 	beq	r4,zero,718 <display_put_number+0x94>
 714:	00004380 	call	438 <display_putpartchar>

		buffernum /= 10;
		n++;
	}

	for(int n=DISPLAY_MAX_DISPLAY_LEN - 1;n>= 0;n--){
 718:	843fffc4 	addi	r16,r16,-1
 71c:	847ffa1e 	bne	r16,r17,708 <_gp+0xffff781e>
		if(znaki[n] != '\0') display_putpartchar(znaki[n]);
	}

	display_load_buffer();
}
 720:	dfc00517 	ldw	ra,20(sp)
 724:	dcc00417 	ldw	r19,16(sp)
 728:	dc800317 	ldw	r18,12(sp)
 72c:	dc400217 	ldw	r17,8(sp)
 730:	dc000117 	ldw	r16,4(sp)
 734:	dec00604 	addi	sp,sp,24

	for(int n=DISPLAY_MAX_DISPLAY_LEN - 1;n>= 0;n--){
		if(znaki[n] != '\0') display_putpartchar(znaki[n]);
	}

	display_load_buffer();
 738:	00004681 	jmpi	468 <display_load_buffer>

0000073c <is_pressed>:
	KEYS_KEY4 = 3,
	KEYS_NOKEY = -1
} tofkey;

int is_pressed(int key){
	if(*KEYS_IDENTITY == KEYS_IDENTIFICATOR){
 73c:	00984004 	movi	r2,24832
 740:	10c00017 	ldw	r3,0(r2)
 744:	00801004 	movi	r2,64
 748:	1880061e 	bne	r3,r2,764 <is_pressed+0x28>
		int* key_addr = KEYS_PRESSED1;
		key_addr += key;
 74c:	2109883a 	add	r4,r4,r4
 750:	2109883a 	add	r4,r4,r4
 754:	21184104 	addi	r4,r4,24836

		int returnme = *key_addr;
 758:	20800017 	ldw	r2,0(r4)
		*key_addr = 0;
 75c:	20000015 	stw	zero,0(r4)
		return returnme;
 760:	f800283a 	ret
	}else{
		return -1;
 764:	00bfffc4 	movi	r2,-1
	}
}
 768:	f800283a 	ret

0000076c <detect_pressed_key>:
}

tofkey detect_pressed_key(){

	int n= KEYS_KEY1;
	for(int* key_addr = KEYS_PRESSED1; key_addr <= KEYS_PRESSED4; key_addr ++){
 76c:	00d84104 	movi	r3,24836
	}
}

tofkey detect_pressed_key(){

	int n= KEYS_KEY1;
 770:	0005883a 	mov	r2,zero
	for(int* key_addr = KEYS_PRESSED1; key_addr <= KEYS_PRESSED4; key_addr ++){
 774:	01000104 	movi	r4,4
		if(*key_addr) return n;
 778:	19400017 	ldw	r5,0(r3)
 77c:	2800041e 	bne	r5,zero,790 <detect_pressed_key+0x24>
		n++;
 780:	10800044 	addi	r2,r2,1
}

tofkey detect_pressed_key(){

	int n= KEYS_KEY1;
	for(int* key_addr = KEYS_PRESSED1; key_addr <= KEYS_PRESSED4; key_addr ++){
 784:	18c00104 	addi	r3,r3,4
 788:	113ffb1e 	bne	r2,r4,778 <_gp+0xffff788e>
		if(*key_addr) return n;
		n++;
	}

	return KEYS_NOKEY;
 78c:	00bfffc4 	movi	r2,-1
}
 790:	f800283a 	ret

00000794 <wait_for_press>:
	}else{
		return -1;
	}
}

int wait_for_press(){
 794:	deffff04 	addi	sp,sp,-4
 798:	dfc00015 	stw	ra,0(sp)
	while(1){
		int id = detect_pressed_key();
 79c:	000076c0 	call	76c <detect_pressed_key>
		if(id != KEYS_NOKEY) return id;
 7a0:	00ffffc4 	movi	r3,-1
 7a4:	10ffff26 	beq	r2,r3,7a4 <_gp+0xffff78ba>
	}
}
 7a8:	dfc00017 	ldw	ra,0(sp)
 7ac:	dec00104 	addi	sp,sp,4
 7b0:	f800283a 	ret

000007b4 <wait_for_press_key>:

void wait_for_press_key(tofkey key){
 7b4:	defffe04 	addi	sp,sp,-8
 7b8:	dc000015 	stw	r16,0(sp)
 7bc:	dfc00115 	stw	ra,4(sp)
 7c0:	2021883a 	mov	r16,r4
	while(1){
		int id = detect_pressed_key();
 7c4:	000076c0 	call	76c <detect_pressed_key>
		if(id == key) return (void)0;
 7c8:	143fff1e 	bne	r2,r16,7c8 <_gp+0xffff78de>
	}
}
 7cc:	dfc00117 	ldw	ra,4(sp)
 7d0:	dc000017 	ldw	r16,0(sp)
 7d4:	dec00204 	addi	sp,sp,8
 7d8:	f800283a 	ret

000007dc <reset_timer>:
}tindex;

void reset_timer(int indexTimer){
	int* timerMem = TIMER1_ADDR;
	timerMem += indexTimer;
	*timerMem = 0;
 7dc:	2109883a 	add	r4,r4,r4
 7e0:	2109883a 	add	r4,r4,r4
 7e4:	20182015 	stw	zero,24704(r4)
 7e8:	f800283a 	ret

000007ec <get_time>:

int get_time(int indexTimer){
	int* timerMem = TIMER1_ADDR;
	timerMem += indexTimer;

	return *timerMem;
 7ec:	2109883a 	add	r4,r4,r4
 7f0:	2109883a 	add	r4,r4,r4
}
 7f4:	20982017 	ldw	r2,24704(r4)
 7f8:	f800283a 	ret

000007fc <set_timer>:
void set_timer(tindex indexTimer, int time){

	int* timerMem = TIMER1_ADDR;
	timerMem += indexTimer;

	*timerMem = time;
 7fc:	2109883a 	add	r4,r4,r4
 800:	2109883a 	add	r4,r4,r4
 804:	21582015 	stw	r5,24704(r4)
 808:	f800283a 	ret

0000080c <wait>:
}tindex;

void reset_timer(int indexTimer){
	int* timerMem = TIMER1_ADDR;
	timerMem += indexTimer;
	*timerMem = 0;
 80c:	00982004 	movi	r2,24704
 810:	10000015 	stw	zero,0(r2)
}

void wait(int millis){
	reset_timer(TIMER1_INDEX);

	while(*TIMER1_ADDR < millis);
 814:	10c00017 	ldw	r3,0(r2)
 818:	193ffe16 	blt	r3,r4,814 <_gp+0xffff792a>
}
 81c:	f800283a 	ret

00000820 <receiveSinglePacket>:
typedef int uart_len;

uart_len receiveSinglePacket(char* received, uart_len n, uart_len lenMax){
	int nx = n;

	while (*FAST_SERIAL_WORK_RECEIV == 1);
 820:	01dc0704 	movi	r7,28700
 824:	00800044 	movi	r2,1
 828:	38c00017 	ldw	r3,0(r7)
 82c:	18bffe26 	beq	r3,r2,828 <_gp+0xffff793e>

	int len = *wiad;
 830:	d0a00097 	ldw	r2,-32766(gp)
	wiad++;

	for(int p=0;p<len ;p++){
 834:	000f883a 	mov	r7,zero
		}

		*wiad = 0;


		if(wiad ==  *FAST_SERIAL_STOP_RECEIV)
 838:	025c0604 	movi	r9,28696
uart_len receiveSinglePacket(char* received, uart_len n, uart_len lenMax){
	int nx = n;

	while (*FAST_SERIAL_WORK_RECEIV == 1);

	int len = *wiad;
 83c:	12000007 	ldb	r8,0(r2)
	wiad++;
 840:	10800044 	addi	r2,r2,1
 844:	d0a00095 	stw	r2,-32766(gp)

		*wiad = 0;


		if(wiad ==  *FAST_SERIAL_STOP_RECEIV)
			wiad = *FAST_SERIAL_START_RECEIV;
 848:	029c0504 	movi	r10,28692
 84c:	d0e00097 	ldw	r3,-32766(gp)
	while (*FAST_SERIAL_WORK_RECEIV == 1);

	int len = *wiad;
	wiad++;

	for(int p=0;p<len ;p++){
 850:	3a00100e 	bge	r7,r8,894 <receiveSinglePacket+0x74>

		if(nx < lenMax){
 854:	2980040e 	bge	r5,r6,868 <receiveSinglePacket+0x48>
			received[nx] = *wiad;
 858:	18c00003 	ldbu	r3,0(r3)
 85c:	2145883a 	add	r2,r4,r5
			nx++;
 860:	29400044 	addi	r5,r5,1
	wiad++;

	for(int p=0;p<len ;p++){

		if(nx < lenMax){
			received[nx] = *wiad;
 864:	10c00005 	stb	r3,0(r2)
			nx++;
		}

		*wiad = 0;
 868:	d0a00097 	ldw	r2,-32766(gp)
 86c:	10000005 	stb	zero,0(r2)


		if(wiad ==  *FAST_SERIAL_STOP_RECEIV)
 870:	48c00017 	ldw	r3,0(r9)
 874:	d0a00097 	ldw	r2,-32766(gp)
 878:	10c0021e 	bne	r2,r3,884 <receiveSinglePacket+0x64>
			wiad = *FAST_SERIAL_START_RECEIV;
 87c:	50800017 	ldw	r2,0(r10)
 880:	00000106 	br	888 <receiveSinglePacket+0x68>
		else wiad ++;
 884:	10800044 	addi	r2,r2,1
 888:	d0a00095 	stw	r2,-32766(gp)
	while (*FAST_SERIAL_WORK_RECEIV == 1);

	int len = *wiad;
	wiad++;

	for(int p=0;p<len ;p++){
 88c:	39c00044 	addi	r7,r7,1
 890:	003fee06 	br	84c <_gp+0xffff7962>
		if(wiad ==  *FAST_SERIAL_STOP_RECEIV)
			wiad = *FAST_SERIAL_START_RECEIV;
		else wiad ++;
	}

	wiad ++;
 894:	18800044 	addi	r2,r3,1
 898:	d0a00095 	stw	r2,-32766(gp)

	if(*wiad == -1) {
 89c:	19000047 	ldb	r4,1(r3)
 8a0:	00bfffc4 	movi	r2,-1
 8a4:	2080051e 	bne	r4,r2,8bc <receiveSinglePacket+0x9c>
		*wiad = 0;
 8a8:	18000045 	stb	zero,1(r3)
		wiad ++;
 8ac:	d0a00097 	ldw	r2,-32766(gp)
 8b0:	10800044 	addi	r2,r2,1
 8b4:	d0a00095 	stw	r2,-32766(gp)

		return nx;
 8b8:	2805883a 	mov	r2,r5
	}else{

		return -1;
	}

}
 8bc:	f800283a 	ret

000008c0 <receiveTiming>:

uart_len receiveTiming(char* received,uart_len lenMax){
 8c0:	defffa04 	addi	sp,sp,-24

	 int n=0;
	 char overflow = 0;

	 int lastStatus = *STATUS_CONNECTED;
 8c4:	009c1804 	movi	r2,28768
		return -1;
	}

}

uart_len receiveTiming(char* received,uart_len lenMax){
 8c8:	dc400115 	stw	r17,4(sp)

	 int n=0;
	 char overflow = 0;

	 int lastStatus = *STATUS_CONNECTED;
 8cc:	14400017 	ldw	r17,0(r2)
		return -1;
	}

}

uart_len receiveTiming(char* received,uart_len lenMax){
 8d0:	dcc00315 	stw	r19,12(sp)
 8d4:	dc800215 	stw	r18,8(sp)
 8d8:	2027883a 	mov	r19,r4
 8dc:	dfc00515 	stw	ra,20(sp)
 8e0:	dd000415 	stw	r20,16(sp)
 8e4:	dc000015 	stw	r16,0(sp)
 8e8:	2825883a 	mov	r18,r5
	 int n=0;
	 char overflow = 0;

	 int lastStatus = *STATUS_CONNECTED;

	 while (*FAST_SERIAL_WORK_RECEIV == 0 && *STATUS_CONNECTED == lastStatus);
 8ec:	011c0704 	movi	r4,28700
 8f0:	20c00017 	ldw	r3,0(r4)
 8f4:	1800021e 	bne	r3,zero,900 <receiveTiming+0x40>
 8f8:	10c00017 	ldw	r3,0(r2)
 8fc:	88fffc26 	beq	r17,r3,8f0 <_gp+0xffff7a06>
 900:	0021883a 	mov	r16,zero
 904:	000b883a 	mov	r5,zero


	 while(1){

		  if(*FAST_SERIAL_WORK_RECEIV == 0){
 908:	051c0704 	movi	r20,28700
 90c:	a0800017 	ldw	r2,0(r20)
 910:	10000726 	beq	r2,zero,930 <receiveTiming+0x70>
			  break;

		  }else{

			  n = receiveSinglePacket(received,n,lenMax);
 914:	900d883a 	mov	r6,r18
 918:	9809883a 	mov	r4,r19
 91c:	00008200 	call	820 <receiveSinglePacket>
 920:	100b883a 	mov	r5,r2

			  if(n >= lenMax) overflow = 1;
 924:	14bff916 	blt	r2,r18,90c <_gp+0xffff7a22>
 928:	04000044 	movi	r16,1
 92c:	003ff706 	br	90c <_gp+0xffff7a22>
		  }
	  }

	  if(*STATUS_CONNECTED != lastStatus) return 0;
 930:	00dc1804 	movi	r3,28768
 934:	18c00017 	ldw	r3,0(r3)
 938:	88c0061e 	bne	r17,r3,954 <receiveTiming+0x94>
	  if(overflow) return -1;
 93c:	84003fcc 	andi	r16,r16,255
 940:	8400201c 	xori	r16,r16,128
 944:	843fe004 	addi	r16,r16,-128
 948:	2805883a 	mov	r2,r5
 94c:	80000126 	beq	r16,zero,954 <receiveTiming+0x94>
 950:	00bfffc4 	movi	r2,-1
	  return n;
}
 954:	dfc00517 	ldw	ra,20(sp)
 958:	dd000417 	ldw	r20,16(sp)
 95c:	dcc00317 	ldw	r19,12(sp)
 960:	dc800217 	ldw	r18,8(sp)
 964:	dc400117 	ldw	r17,4(sp)
 968:	dc000017 	ldw	r16,0(sp)
 96c:	dec00604 	addi	sp,sp,24
 970:	f800283a 	ret

00000974 <beginReceiver>:

int beginReceiver(int* buffer, uart_len len){

	char* lbuffer = (char*)buffer;

	if(len > 0){
 974:	01401a0e 	bge	zero,r5,9e0 <beginReceiver+0x6c>
	  if(*STATUS_CONNECTED != lastStatus) return 0;
	  if(overflow) return -1;
	  return n;
}

int beginReceiver(int* buffer, uart_len len){
 978:	defffc04 	addi	sp,sp,-16
 97c:	dc800215 	stw	r18,8(sp)
 980:	dc400115 	stw	r17,4(sp)
 984:	dc000015 	stw	r16,0(sp)
 988:	dfc00315 	stw	ra,12(sp)

	char* lbuffer = (char*)buffer;

	if(len > 0){
		 *FAST_SERIAL_ENABLE_RECEIV = 0;
 98c:	049c0404 	movi	r18,28688
 990:	90000015 	stw	zero,0(r18)
 994:	2023883a 	mov	r17,r4
 998:	2821883a 	mov	r16,r5

		  cleanBuffer(lbuffer,len);
 99c:	0000ab00 	call	ab0 <cleanBuffer>

		  *FAST_SERIAL_START_RECEIV = lbuffer;
 9a0:	00dc0504 	movi	r3,28692
		  *FAST_SERIAL_STOP_RECEIV = lbuffer + len - 1;
 9a4:	80bfffc4 	addi	r2,r16,-1
	if(len > 0){
		 *FAST_SERIAL_ENABLE_RECEIV = 0;

		  cleanBuffer(lbuffer,len);

		  *FAST_SERIAL_START_RECEIV = lbuffer;
 9a8:	1c400015 	stw	r17,0(r3)
		  *FAST_SERIAL_STOP_RECEIV = lbuffer + len - 1;
 9ac:	8885883a 	add	r2,r17,r2
 9b0:	011c0604 	movi	r4,28696
 9b4:	20800015 	stw	r2,0(r4)

		  wiad = *FAST_SERIAL_START_RECEIV;
 9b8:	18800017 	ldw	r2,0(r3)
 9bc:	d0a00095 	stw	r2,-32766(gp)

		  *FAST_SERIAL_ENABLE_RECEIV = 1;
 9c0:	00800044 	movi	r2,1
 9c4:	90800015 	stw	r2,0(r18)

		  return 1;
	} else return 0;
}
 9c8:	dfc00317 	ldw	ra,12(sp)
 9cc:	dc800217 	ldw	r18,8(sp)
 9d0:	dc400117 	ldw	r17,4(sp)
 9d4:	dc000017 	ldw	r16,0(sp)
 9d8:	dec00404 	addi	sp,sp,16
 9dc:	f800283a 	ret
		  wiad = *FAST_SERIAL_START_RECEIV;

		  *FAST_SERIAL_ENABLE_RECEIV = 1;

		  return 1;
	} else return 0;
 9e0:	0005883a 	mov	r2,zero
 9e4:	f800283a 	ret

000009e8 <closeReceiver>:
}

void closeReceiver() {
	*FAST_SERIAL_ENABLE_RECEIV = 0;
 9e8:	009c0404 	movi	r2,28688
 9ec:	10000015 	stw	zero,0(r2)
 9f0:	f800283a 	ret

000009f4 <receive>:
}

uart_len receive(char* received,uart_len len){
	return receiveTiming(received,len);
 9f4:	00008c01 	jmpi	8c0 <receiveTiming>

000009f8 <sendIt>:

typedef int uart_len;

int sendIt(char* message,uart_len len){

	while (*FAST_SERIAL_SEND_WORK == 1);
 9f8:	01800304 	movi	r6,12
 9fc:	00800044 	movi	r2,1
 a00:	30c00017 	ldw	r3,0(r6)
 a04:	18bffe26 	beq	r3,r2,a00 <_gp+0xffff7b16>
 a08:	0005883a 	mov	r2,zero

	char* startAddr = &message[0];
	char* stopAddr = 0;

	for(int n=0;n<len;n++){
		if(n == len - 1){
 a0c:	28ffffc4 	addi	r3,r5,-1
	while (*FAST_SERIAL_SEND_WORK == 1);

	char* startAddr = &message[0];
	char* stopAddr = 0;

	for(int n=0;n<len;n++){
 a10:	1140120e 	bge	r2,r5,a5c <sendIt+0x64>
		if(n == len - 1){
 a14:	10c00b1e 	bne	r2,r3,a44 <sendIt+0x4c>
			stopAddr = &message[n];
 a18:	2085883a 	add	r2,r4,r2
			break;
		}
	}

	if(stopAddr == 0) return 0;
 a1c:	10000f26 	beq	r2,zero,a5c <sendIt+0x64>

	*FAST_SERIAL_START_ADDR = startAddr;
 a20:	00dc0104 	movi	r3,28676
 a24:	19000015 	stw	r4,0(r3)
	*FAST_SERIAL_STOP_ADDR = stopAddr;
 a28:	00dc0204 	movi	r3,28680
 a2c:	18800015 	stw	r2,0(r3)
	*FAST_SERIAL_SEND_START = 1;
 a30:	00800044 	movi	r2,1
 a34:	00dc0004 	movi	r3,28672
 a38:	18800015 	stw	r2,0(r3)

	while (*FAST_SERIAL_SEND_WORK == 1);
 a3c:	01000304 	movi	r4,12
 a40:	00000206 	br	a4c <sendIt+0x54>
	while (*FAST_SERIAL_SEND_WORK == 1);

	char* startAddr = &message[0];
	char* stopAddr = 0;

	for(int n=0;n<len;n++){
 a44:	10800044 	addi	r2,r2,1
 a48:	003ff106 	br	a10 <_gp+0xffff7b26>

	*FAST_SERIAL_START_ADDR = startAddr;
	*FAST_SERIAL_STOP_ADDR = stopAddr;
	*FAST_SERIAL_SEND_START = 1;

	while (*FAST_SERIAL_SEND_WORK == 1);
 a4c:	20c00017 	ldw	r3,0(r4)
 a50:	18bffe26 	beq	r3,r2,a4c <_gp+0xffff7b62>
	return 1;
 a54:	00800044 	movi	r2,1
 a58:	f800283a 	ret
			stopAddr = &message[n];
			break;
		}
	}

	if(stopAddr == 0) return 0;
 a5c:	0005883a 	mov	r2,zero
	*FAST_SERIAL_STOP_ADDR = stopAddr;
	*FAST_SERIAL_SEND_START = 1;

	while (*FAST_SERIAL_SEND_WORK == 1);
	return 1;
}
 a60:	f800283a 	ret

00000a64 <printviau>:
#define MAX_RECEIVED_MESSAGE_LEN 128


void printviau(char* string){
 a64:	2005883a 	mov	r2,r4
	int len = 0;
 a68:	000b883a 	mov	r5,zero
	for(int n=0;n<MAX_RECEIVED_MESSAGE_LEN;n++){
		len ++;

		if(string[n] == 10) break;
 a6c:	01800284 	movi	r6,10
#define MAX_RECEIVED_MESSAGE_LEN 128


void printviau(char* string){
	int len = 0;
	for(int n=0;n<MAX_RECEIVED_MESSAGE_LEN;n++){
 a70:	00c02004 	movi	r3,128
		len ++;

		if(string[n] == 10) break;
 a74:	11c00007 	ldb	r7,0(r2)


void printviau(char* string){
	int len = 0;
	for(int n=0;n<MAX_RECEIVED_MESSAGE_LEN;n++){
		len ++;
 a78:	29400044 	addi	r5,r5,1

		if(string[n] == 10) break;
 a7c:	3980011e 	bne	r7,r6,a84 <printviau+0x20>
	}

	sendIt(string,len);
 a80:	00009f81 	jmpi	9f8 <sendIt>
 a84:	10800044 	addi	r2,r2,1
#define MAX_RECEIVED_MESSAGE_LEN 128


void printviau(char* string){
	int len = 0;
	for(int n=0;n<MAX_RECEIVED_MESSAGE_LEN;n++){
 a88:	28fffa1e 	bne	r5,r3,a74 <_gp+0xffff7b8a>
 a8c:	003ffc06 	br	a80 <_gp+0xffff7b96>

00000a90 <pause>:

	sendIt(string,len);

}

void pause(void){
 a90:	deffff04 	addi	sp,sp,-4
 a94:	dfc00015 	stw	ra,0(sp)
	  while(1){
		  if(is_pressed(0)) break;
 a98:	0009883a 	mov	r4,zero
 a9c:	000073c0 	call	73c <is_pressed>
 aa0:	103ffd26 	beq	r2,zero,a98 <_gp+0xffff7bae>
	  }
}
 aa4:	dfc00017 	ldw	ra,0(sp)
 aa8:	dec00104 	addi	sp,sp,4
 aac:	f800283a 	ret

00000ab0 <cleanBuffer>:
void cleanBuffer(char* buffer, int len){

	for(int n=0;n<len;n++){
 ab0:	2005883a 	mov	r2,r4
 ab4:	1107c83a 	sub	r3,r2,r4
 ab8:	1940030e 	bge	r3,r5,ac8 <cleanBuffer+0x18>
		*buffer = '\0';
 abc:	10000005 	stb	zero,0(r2)
		buffer++;
 ac0:	10800044 	addi	r2,r2,1
 ac4:	003ffb06 	br	ab4 <_gp+0xffff7bca>
	}
}
 ac8:	f800283a 	ret

00000acc <__divsi3>:
 acc:	20001b16 	blt	r4,zero,b3c <__divsi3+0x70>
 ad0:	000f883a 	mov	r7,zero
 ad4:	28001616 	blt	r5,zero,b30 <__divsi3+0x64>
 ad8:	200d883a 	mov	r6,r4
 adc:	29001a2e 	bgeu	r5,r4,b48 <__divsi3+0x7c>
 ae0:	00800804 	movi	r2,32
 ae4:	00c00044 	movi	r3,1
 ae8:	00000106 	br	af0 <__divsi3+0x24>
 aec:	10000d26 	beq	r2,zero,b24 <__divsi3+0x58>
 af0:	294b883a 	add	r5,r5,r5
 af4:	10bfffc4 	addi	r2,r2,-1
 af8:	18c7883a 	add	r3,r3,r3
 afc:	293ffb36 	bltu	r5,r4,aec <_gp+0xffff7c02>
 b00:	0005883a 	mov	r2,zero
 b04:	18000726 	beq	r3,zero,b24 <__divsi3+0x58>
 b08:	0005883a 	mov	r2,zero
 b0c:	31400236 	bltu	r6,r5,b18 <__divsi3+0x4c>
 b10:	314dc83a 	sub	r6,r6,r5
 b14:	10c4b03a 	or	r2,r2,r3
 b18:	1806d07a 	srli	r3,r3,1
 b1c:	280ad07a 	srli	r5,r5,1
 b20:	183ffa1e 	bne	r3,zero,b0c <_gp+0xffff7c22>
 b24:	38000126 	beq	r7,zero,b2c <__divsi3+0x60>
 b28:	0085c83a 	sub	r2,zero,r2
 b2c:	f800283a 	ret
 b30:	014bc83a 	sub	r5,zero,r5
 b34:	39c0005c 	xori	r7,r7,1
 b38:	003fe706 	br	ad8 <_gp+0xffff7bee>
 b3c:	0109c83a 	sub	r4,zero,r4
 b40:	01c00044 	movi	r7,1
 b44:	003fe306 	br	ad4 <_gp+0xffff7bea>
 b48:	00c00044 	movi	r3,1
 b4c:	003fee06 	br	b08 <_gp+0xffff7c1e>

00000b50 <__modsi3>:
 b50:	20001716 	blt	r4,zero,bb0 <__modsi3+0x60>
 b54:	000f883a 	mov	r7,zero
 b58:	2005883a 	mov	r2,r4
 b5c:	28001216 	blt	r5,zero,ba8 <__modsi3+0x58>
 b60:	2900162e 	bgeu	r5,r4,bbc <__modsi3+0x6c>
 b64:	01800804 	movi	r6,32
 b68:	00c00044 	movi	r3,1
 b6c:	00000106 	br	b74 <__modsi3+0x24>
 b70:	30000a26 	beq	r6,zero,b9c <__modsi3+0x4c>
 b74:	294b883a 	add	r5,r5,r5
 b78:	31bfffc4 	addi	r6,r6,-1
 b7c:	18c7883a 	add	r3,r3,r3
 b80:	293ffb36 	bltu	r5,r4,b70 <_gp+0xffff7c86>
 b84:	18000526 	beq	r3,zero,b9c <__modsi3+0x4c>
 b88:	1806d07a 	srli	r3,r3,1
 b8c:	11400136 	bltu	r2,r5,b94 <__modsi3+0x44>
 b90:	1145c83a 	sub	r2,r2,r5
 b94:	280ad07a 	srli	r5,r5,1
 b98:	183ffb1e 	bne	r3,zero,b88 <_gp+0xffff7c9e>
 b9c:	38000126 	beq	r7,zero,ba4 <__modsi3+0x54>
 ba0:	0085c83a 	sub	r2,zero,r2
 ba4:	f800283a 	ret
 ba8:	014bc83a 	sub	r5,zero,r5
 bac:	003fec06 	br	b60 <_gp+0xffff7c76>
 bb0:	0109c83a 	sub	r4,zero,r4
 bb4:	01c00044 	movi	r7,1
 bb8:	003fe706 	br	b58 <_gp+0xffff7c6e>
 bbc:	00c00044 	movi	r3,1
 bc0:	003ff106 	br	b88 <_gp+0xffff7c9e>

00000bc4 <__udivsi3>:
 bc4:	200d883a 	mov	r6,r4
 bc8:	2900152e 	bgeu	r5,r4,c20 <__udivsi3+0x5c>
 bcc:	28001416 	blt	r5,zero,c20 <__udivsi3+0x5c>
 bd0:	00800804 	movi	r2,32
 bd4:	00c00044 	movi	r3,1
 bd8:	00000206 	br	be4 <__udivsi3+0x20>
 bdc:	10000e26 	beq	r2,zero,c18 <__udivsi3+0x54>
 be0:	28000516 	blt	r5,zero,bf8 <__udivsi3+0x34>
 be4:	294b883a 	add	r5,r5,r5
 be8:	10bfffc4 	addi	r2,r2,-1
 bec:	18c7883a 	add	r3,r3,r3
 bf0:	293ffa36 	bltu	r5,r4,bdc <_gp+0xffff7cf2>
 bf4:	18000826 	beq	r3,zero,c18 <__udivsi3+0x54>
 bf8:	0005883a 	mov	r2,zero
 bfc:	31400236 	bltu	r6,r5,c08 <__udivsi3+0x44>
 c00:	314dc83a 	sub	r6,r6,r5
 c04:	10c4b03a 	or	r2,r2,r3
 c08:	1806d07a 	srli	r3,r3,1
 c0c:	280ad07a 	srli	r5,r5,1
 c10:	183ffa1e 	bne	r3,zero,bfc <_gp+0xffff7d12>
 c14:	f800283a 	ret
 c18:	0005883a 	mov	r2,zero
 c1c:	f800283a 	ret
 c20:	00c00044 	movi	r3,1
 c24:	003ff406 	br	bf8 <_gp+0xffff7d0e>

00000c28 <__umodsi3>:
 c28:	2005883a 	mov	r2,r4
 c2c:	2900122e 	bgeu	r5,r4,c78 <__umodsi3+0x50>
 c30:	28001116 	blt	r5,zero,c78 <__umodsi3+0x50>
 c34:	01800804 	movi	r6,32
 c38:	00c00044 	movi	r3,1
 c3c:	00000206 	br	c48 <__umodsi3+0x20>
 c40:	30000c26 	beq	r6,zero,c74 <__umodsi3+0x4c>
 c44:	28000516 	blt	r5,zero,c5c <__umodsi3+0x34>
 c48:	294b883a 	add	r5,r5,r5
 c4c:	31bfffc4 	addi	r6,r6,-1
 c50:	18c7883a 	add	r3,r3,r3
 c54:	293ffa36 	bltu	r5,r4,c40 <_gp+0xffff7d56>
 c58:	18000626 	beq	r3,zero,c74 <__umodsi3+0x4c>
 c5c:	1806d07a 	srli	r3,r3,1
 c60:	11400136 	bltu	r2,r5,c68 <__umodsi3+0x40>
 c64:	1145c83a 	sub	r2,r2,r5
 c68:	280ad07a 	srli	r5,r5,1
 c6c:	183ffb1e 	bne	r3,zero,c5c <_gp+0xffff7d72>
 c70:	f800283a 	ret
 c74:	f800283a 	ret
 c78:	00c00044 	movi	r3,1
 c7c:	003ff706 	br	c5c <_gp+0xffff7d72>

00000c80 <__mulsi3>:
 c80:	0005883a 	mov	r2,zero
 c84:	20000726 	beq	r4,zero,ca4 <__mulsi3+0x24>
 c88:	20c0004c 	andi	r3,r4,1
 c8c:	2008d07a 	srli	r4,r4,1
 c90:	18000126 	beq	r3,zero,c98 <__mulsi3+0x18>
 c94:	1145883a 	add	r2,r2,r5
 c98:	294b883a 	add	r5,r5,r5
 c9c:	203ffa1e 	bne	r4,zero,c88 <_gp+0xffff7d9e>
 ca0:	f800283a 	ret
 ca4:	f800283a 	ret

00000ca8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 ca8:	deffff04 	addi	sp,sp,-4
 cac:	01000034 	movhi	r4,0
 cb0:	01400034 	movhi	r5,0
 cb4:	dfc00015 	stw	ra,0(sp)
 cb8:	2103b604 	addi	r4,r4,3800
 cbc:	2943bd04 	addi	r5,r5,3828

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 cc0:	2140061e 	bne	r4,r5,cdc <alt_load+0x34>
 cc4:	01000034 	movhi	r4,0
 cc8:	01400034 	movhi	r5,0
 ccc:	21000804 	addi	r4,r4,32
 cd0:	29400804 	addi	r5,r5,32
 cd4:	2140121e 	bne	r4,r5,d20 <alt_load+0x78>
 cd8:	00000b06 	br	d08 <alt_load+0x60>
 cdc:	00c00034 	movhi	r3,0
 ce0:	18c3bd04 	addi	r3,r3,3828
 ce4:	1907c83a 	sub	r3,r3,r4
 ce8:	0005883a 	mov	r2,zero
  {
    while( to != end )
 cec:	10fff526 	beq	r2,r3,cc4 <_gp+0xffff7dda>
    {
      *to++ = *from++;
 cf0:	114f883a 	add	r7,r2,r5
 cf4:	39c00017 	ldw	r7,0(r7)
 cf8:	110d883a 	add	r6,r2,r4
 cfc:	10800104 	addi	r2,r2,4
 d00:	31c00015 	stw	r7,0(r6)
 d04:	003ff906 	br	cec <_gp+0xffff7e02>
 d08:	01000034 	movhi	r4,0
 d0c:	01400034 	movhi	r5,0
 d10:	21037a04 	addi	r4,r4,3560
 d14:	29437a04 	addi	r5,r5,3560

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 d18:	2140101e 	bne	r4,r5,d5c <alt_load+0xb4>
 d1c:	00000b06 	br	d4c <alt_load+0xa4>
 d20:	00c00034 	movhi	r3,0
 d24:	18c00804 	addi	r3,r3,32
 d28:	1907c83a 	sub	r3,r3,r4
 d2c:	0005883a 	mov	r2,zero
  {
    while( to != end )
 d30:	10fff526 	beq	r2,r3,d08 <_gp+0xffff7e1e>
    {
      *to++ = *from++;
 d34:	114f883a 	add	r7,r2,r5
 d38:	39c00017 	ldw	r7,0(r7)
 d3c:	110d883a 	add	r6,r2,r4
 d40:	10800104 	addi	r2,r2,4
 d44:	31c00015 	stw	r7,0(r6)
 d48:	003ff906 	br	d30 <_gp+0xffff7e46>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 d4c:	0000dd80 	call	dd8 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 d50:	dfc00017 	ldw	ra,0(sp)
 d54:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 d58:	0000ddc1 	jmpi	ddc <alt_icache_flush_all>
 d5c:	00c00034 	movhi	r3,0
 d60:	18c3b604 	addi	r3,r3,3800
 d64:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 d68:	0005883a 	mov	r2,zero
  {
    while( to != end )
 d6c:	18bff726 	beq	r3,r2,d4c <_gp+0xffff7e62>
    {
      *to++ = *from++;
 d70:	114f883a 	add	r7,r2,r5
 d74:	39c00017 	ldw	r7,0(r7)
 d78:	110d883a 	add	r6,r2,r4
 d7c:	10800104 	addi	r2,r2,4
 d80:	31c00015 	stw	r7,0(r6)
 d84:	003ff906 	br	d6c <_gp+0xffff7e82>

00000d88 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 d88:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 d8c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 d90:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 d94:	0000db40 	call	db4 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 d98:	0000dd40 	call	dd4 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 d9c:	d1a00a97 	ldw	r6,-32726(gp)
 da0:	d1600b97 	ldw	r5,-32722(gp)
 da4:	d1200c97 	ldw	r4,-32718(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 da8:	dfc00017 	ldw	ra,0(sp)
 dac:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 db0:	00002101 	jmpi	210 <main>

00000db4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 db4:	deffff04 	addi	sp,sp,-4
 db8:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, CPU);
 dbc:	0000de00 	call	de0 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 dc0:	00800044 	movi	r2,1
 dc4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 dc8:	dfc00017 	ldw	ra,0(sp)
 dcc:	dec00104 	addi	sp,sp,4
 dd0:	f800283a 	ret

00000dd4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 dd4:	f800283a 	ret

00000dd8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 dd8:	f800283a 	ret

00000ddc <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 ddc:	f800283a 	ret

00000de0 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 de0:	000170fa 	wrctl	ienable,zero
 de4:	f800283a 	ret
